'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/posts/','title':"Posts",'content':""});index.add({'id':1,'href':'/posts/ch2/context/','title':"上下文",'content':"2.4 上下文 上下文（Context）是 Go 语言中非常有特色的一个特性， 在 Go 1.7 版本中正式引入新标准库 context。其主要的作用是在 goroutine 中进行上下文的传递，而在传递信息中又包含了 goroutine 的运行控制、上下文信息传递等功能。\n为加强大家对 Go 语言的 context 的设计，本文将对标准库 context 进行深入剖析，看看他里面到底暗含了何物，又为何能够做那么多事。\n整体的描述结构是：“了解 context 特性，熟悉 context 流程，剖析 context 原理” 三个板块进行。\n2.4.1 什么是 context Go 语言的独有的功能之一 Context，最常听说开发者说的一句话就是 “函数的第一个形参真的要传 ctx 吗？”，第二句话可能是 “有没有什么办法不传，就能达到传入的效果？”，听起来非常魔幻。\n在 Go 语言中 context 作为一个 “一等公民” 的标准库，许多的开源库都一定会对他进行支持，因为标准库 context 的定位是上下文控制。会在跨 goroutine 中进行传播：\n本质上 Go 语言是基于 context 来实现和搭建了各类 goroutine 控制的，并且与 select-case 联合，就可以实现进行上下文的截止时间、信号控制、信息传递等跨 goroutine 的操作，是 Go 语言协程的重中之重。\n2.4.2 context 基本特性 演示代码：\nfunc main() { parentCtx := context.Background() ctx, cancel := context.WithTimeout(parentCtx, 1*time.Millisecond) defer cancel() select { case \u0026lt;-time.After(1 * time.Second): fmt.Println(\u0026quot;overslept\u0026quot;) case \u0026lt;-ctx.Done(): fmt.Println(ctx.Err()) } } 输出结果：\ncontext deadline exceeded 我们通过调用标准库 context.WithTimeout 方法针对 parentCtx 变量设置了超时时间，并在随后调用 select-case 进行 context.Done 方法的监听，最后由于达到截止时间。因此逻辑上 select 走到了 context.Err 的 case 分支，最终输出 context deadline exceeded。\n除了上述所描述的方法外，标准库 context 还支持下述方法：\nfunc WithCancel(parent Context) (ctx Context, cancel CancelFunc) func WithDeadline(parent Context, d time.Time) (Context, CancelFunc) func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc) type Context func Background() Context func TODO() Context func WithValue(parent Context, key, val interface{}) Context  WithCancel：基于父级 context，创建一个可以取消的新 context。 WithDeadline：基于父级 context，创建一个具有截止时间（Deadline）的新 context。 WithTimeout：基于父级 context，创建一个具有超时时间（Timeout）的新 context。 Background：创建一个空的 context，一般常用于作为根的父级 context。 TODO：创建一个空的 context，一般用于未确定时的声明使用。 WithValue：基于某个 context 创建并存储对应的上下文信息。  2.4.3 context 本质 我们在基本特性中介绍了不少 context 的方法，其基本大同小异。看上去似乎不难，接下来我们看看其底层的基本原理和设计。\ncontext 相关函数的标准返回如下：\nfunc WithXXXX(parent Context, xxx xxx) (Context, CancelFunc) 其返回值分别是 Context 和 CancelFunc，接下来我们将进行分析这两者的作用。\n2.4.3.1 接口  Context 接口：  type Context interface { Deadline() (deadline time.Time, ok bool) Done() \u0026lt;-chan struct{} Err() error Value(key interface{}) interface{} }  Deadline：获取当前 context 的截止时间。 Done：获取一个只读的 channel，类型为结构体。可用于识别当前 channel 是否已经被关闭，其原因可能是到期，也可能是被取消了。 Err：获取当前 context 被关闭的原因。 Value：获取当前 context 对应所存储的上下文信息。  Canceler 接口：  type canceler interface { cancel(removeFromParent bool, err error) Done() \u0026lt;-chan struct{} }  cancel：调用当前 context 的取消方法。 Done：与前面一致，可用于识别当前 channel 是否已经被关闭。  2.4.3.2 基础结构 在标准库 context 的设计上，一共提供了四类 context 类型来实现上述接口。分别是 emptyCtx、cancelCtx、timerCtx 以及 valueCtx。\n2.4.3.2.1 emptyCtx 在日常使用中，常常使用到的 context.Background 方法，又或是 context.TODO 方法。\n源码如下：\nvar ( background = new(emptyCtx) todo = new(emptyCtx) ) func Background() Context { return background } func TODO() Context { return todo } 其本质上都是基于 emptyCtx 类型的基本封装。而 emptyCtx 类型本质上是实现了 Context 接口：\ntype emptyCtx int func (*emptyCtx) Deadline() (deadline time.Time, ok bool) { return } func (*emptyCtx) Done() \u0026lt;-chan struct{} { return nil } func (*emptyCtx) Err() error { return nil } func (*emptyCtx) Value(key interface{}) interface{} { return nil } 实际上 emptyCtx 类型的 context 的实现非常简单，因为他是空 context 的定义，因此没有 deadline，更没有 timeout，可以认为就是一个基础空白 context 模板。\n2.4.3.2.2 cancelCtx 在调用 context.WithCancel 方法时，我们会涉及到 cancelCtx 类型，其主要特性是取消事件。源码如下：\nfunc WithCancel(parent Context) (ctx Context, cancel CancelFunc) { c := newCancelCtx(parent) propagateCancel(parent, \u0026amp;c) return \u0026amp;c, func() { c.cancel(true, Canceled) } } func newCancelCtx(parent Context) cancelCtx { return cancelCtx{Context: parent} } 其中的 newCancelCtx 方法将会生成出一个可以取消的新 context，如果该 context 执行取消，与其相关联的子 context 以及对应的 goroutine 也会收到取消信息。\n首先 main goroutine 创建并传递了一个新的 context 给 goroutine b，此时 goroutine b 的 context 是 main goroutine context 的子集：\n传递过程中，goroutine b 再将其 context 一个个传递给了 goroutine c、d、e。最后在运行时 goroutine b 调用了 cancel 方法。使得该 context 以及其对应的子集均接受到取消信号，对应的 goroutine 也进行了响应。\n接下来我们针对 cancelCtx 类型来进一步看看：\ntype cancelCtx struct { Context mu sync.Mutex // protects following fields done chan struct{} // created lazily, closed by first cancel call children map[canceler]struct{} // set to nil by the first cancel call err error // set to non-nil by the first cancel call } 该结构体所包含的属性也比较简单，主要是 children 字段，其包含了该 context 对应的所有子集 context，便于在后续发生取消事件的时候进行逐一通知和关联。\n而其他的属性主要用于并发控制（互斥锁）、取消信息和错误的写入：\nfunc (c *cancelCtx) Value(key interface{}) interface{} { if key == \u0026amp;cancelCtxKey { return c } return c.Context.Value(key) } func (c *cancelCtx) Done() \u0026lt;-chan struct{} { c.mu.Lock() if c.done == nil { c.done = make(chan struct{}) } d := c.done c.mu.Unlock() return d } func (c *cancelCtx) Err() error { c.mu.Lock() err := c.err c.mu.Unlock() return err } 在上述代码中可以留意到，done 属性（只读 channel）是在真正调用到 Done 方法时才会去创建。需要配合 select-case 来使用。\n2.4.3.2.3 timerCtx 在调用 context.WithTimeout 方法时，我们会涉及到 timerCtx 类型，其主要特性是 Timeout 和 Deadline 事件，源码如下：\nfunc WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc) { return WithDeadline(parent, time.Now().Add(timeout)) } func WithDeadline(parent Context, d time.Time) (Context, CancelFunc) { ... c := \u0026amp;timerCtx{ cancelCtx: newCancelCtx(parent), deadline: d, } } 你可以发现 timerCtx 类型是基于 cancelCtx 类型的。我们再进一步看看 timerCtx 结构体：\ntype timerCtx struct { cancelCtx timer *time.Timer // Under cancelCtx.mu. deadline time.Time } 其实 timerCtx 类型也就是 cancelCtx 类型，加上 time.Timer 和对应的 Deadline，也就是包含了时间属性的控制。\n我们进一步看看其配套的 cancel 方法，思考一下其是如何进行取消动作的：\nfunc (c *timerCtx) Deadline() (deadline time.Time, ok bool) { return c.deadline, true } func (c *timerCtx) cancel(removeFromParent bool, err error) { c.cancelCtx.cancel(false, err) if removeFromParent { removeChild(c.cancelCtx.Context, c) } c.mu.Lock() if c.timer != nil { c.timer.Stop() c.timer = nil } c.mu.Unlock() } 先会调用 cancelCtx 类型的取消事件。若存在父级节点，则移除当前 context 子节点，最后停止定时器并进行定时器重置。而 Deadline 或 Timeout 的行为则由 timerCtx 的 WithDeadline 方法实现：\nfunc WithDeadline(parent Context, d time.Time) (Context, CancelFunc) { if cur, ok := parent.Deadline(); ok \u0026amp;\u0026amp; cur.Before(d) { // The current deadline is already sooner than the new one. return WithCancel(parent) } ... } 该方法会先进行前置判断，若父级节点的 Deadline 时间早于当前所指定的 Deadline 时间，将会直接生成一个 cancelCtx 的 context。\nfunc WithDeadline(parent Context, d time.Time) (Context, CancelFunc) { ... c := \u0026amp;timerCtx{ cancelCtx: newCancelCtx(parent), deadline: d, } propagateCancel(parent, c) dur := time.Until(d) if dur \u0026lt;= 0 { c.cancel(true, DeadlineExceeded) // deadline has already passed return c, func() { c.cancel(false, Canceled) } } c.mu.Lock() defer c.mu.Unlock() if c.err == nil { c.timer = time.AfterFunc(dur, func() { c.cancel(true, DeadlineExceeded) }) } return c, func() { c.cancel(true, Canceled) } } 接下来将会正式生成成为一个 timeCtx 类型，并将其加入到父级 context 是 children 属性中。最后进行当前时间与 Deadline 时间的计算，并通过调用 time.AfterFunc 在到期后自动调用 cancel 方法发起取消事件，自然也就会触发父子级的事件传播。\n2.4.3.2.4 valueCtx 在调用 context.WithValue 方法时，我们会涉及到 valueCtx 类型，其主要特性是涉及上下文信息传递，源码如下：\nfunc WithValue(parent Context, key, val interface{}) Context { ... if !reflectlite.TypeOf(key).Comparable() { panic(\u0026quot;key is not comparable\u0026quot;) } return \u0026amp;valueCtx{parent, key, val} } 你会发现 valueCtx 结构体也非常的简单，核心就是键值对：\ntype valueCtx struct { Context key, val interface{} } 其在配套方法上也不会太复杂，基本就是要求可比较，接着就是存储匹配：\nfunc (c *valueCtx) Value(key interface{}) interface{} { if c.key == key { return c.val } return c.Context.Value(key) } 这时候你可能又有疑问了，那多个父子级 context 是如何实现跨 context 的上下文信息获取的？\n这秘密其实在上面的 valueCtx 和 Value 方法中有所表现：\n本质上 valueCtx 类型是一个单向链表，会在调用 Value 方法时先查询自己的节点是否有该值。若无，则会通过自身存储的上层父级节点的信息一层层向上寻找对应的值，直到找到为止。\n而在实际的工程应用中，你会发现各大框架，例如：gin、grpc 等。他都是有自己再实现一套上下文信息的传输的二次封装，本意也是为了更好的管理和观察上下文信息。\n2.4.4 context 取消事件 在我们针对 context 的各类延伸类型和源码进行了分析后。我们进一步提出一个疑问点，context 是如何实现跨 goroutine 的取消事件并传播开来的，是如何实现的？\n这个问题的答案就在于 WithCancel 和 WithDeadline 都会涉及到 propagateCancel 方法，其作用是构建父子级的上下文的关联关系，若出现取消事件时，就会进行处理：\nfunc propagateCancel(parent Context, child canceler) { done := parent.Done() if done == nil { return } select { case \u0026lt;-done: child.cancel(false, parent.Err()) return default: } ... }  当父级上下文（parent）的 Done 结果为 nil 时，将会直接返回，因为其不会具备取消事件的基本条件，可能该 context 是 Background、TODO 等方法产生的空白 context。 当父级上下文（parent）的 Done 结果不为 nil 时，则发现父级上下文已经被取消，作为其子级，该 context 将会触发取消事件并返回父级上下文的取消原因。  func propagateCancel(parent Context, child canceler) { ... if p, ok := parentCancelCtx(parent); ok { p.mu.Lock() if p.err != nil { child.cancel(false, p.err) } else { if p.children == nil { p.children = make(map[canceler]struct{}) } p.children[child] = struct{}{} } p.mu.Unlock() } else { atomic.AddInt32(\u0026amp;goroutines, +1) go func() { select { case \u0026lt;-parent.Done(): child.cancel(false, parent.Err()) case \u0026lt;-child.Done(): } }() } } 经过前面一个代码片段的判断，已得知父级 context 未触发取消事件，当前父级和子级 context 均正常（未取消）。\n将会执行以下流程：\n 调用 parentCancelCtx 方法找到具备取消功能的父级 context。并将当前 context，也就是 child 加入到 父级 context 的 children 列表中，等待后续父级 context 的取消事件通知和响应。 调用 parentCancelCtx 方法没有找到，将会启动一个新的 goroutine 去监听父子 context 的取消事件通知。  通过对 context 的取消事件和整体源码分析，可得知 cancelCtx 类型的上下文包含了其下属的所有子节点信息：\n也就是其在 children 属性的 map[canceler]struct{} 存储结构上就已经支持了子级关系的查找，也就自然可以进行取消事件传播了。\n而具体的取消事件的实际行为，则是在前面提到的 propagateCancel 方法中，会在执行例如 cacenl 方法时，会对父子级上下文分别进行状态判断，若满足则进行取消事件，并传播给子级同步取消。\n2.4.5 总结 作为 Go 语言的核心功能之一，其实标准库 context 非常的短小精悍，使用的都是基本的数据结构和理念。既满足了跨 goroutine 的调控控制，像是并发、超时控制等。\n同时也满足了上下文的信息传递。在工程应用中，例如像是链路ID、公共参数、鉴权校验等，都会使用到 context 作为媒介。\n目前官方对于 context 的建议是作为方法的首参数传入，虽有些麻烦，但也有人选择将其作为结构体中的一个属性传入。但这也会带来一些心智负担，需要识别是否重新 new 一个。\n也有人提出希望 Go2 取消掉 context，换成另外一种方法，但总体而言目前未见到正式的提案，这是我们都需要再思考的。\n"});index.add({'id':2,'href':'/posts/ch2/reflect/','title':"反射",'content':"2.1 反射 在所有的语言中，反射这一功能基本属于必不可少的模块。虽说 “反射” 这个词让人根深蒂固，但更多的还是 WHY。反射到底是什么，反射又是基于什么法则实现的？\n本章节以 Go 语言为例，了解反射到底为何物，其底层又是如何实现的。\n反射是什么 在计算机学中，反射是指计算机程序在运行时（runtime）可以访问、检测和修改它本身状态或行为的一种能力。用比喻来说，反射就是程序在运行的时候能够 “观察” 并且修改自己的行为（来自维基百科）。\n简单来讲就是，应用程序能够在运行时观察到变量的值，并且能够修改他。\n一个例子 最常见的 reflect 标准库例子，如下：\nimport ( \u0026quot;fmt\u0026quot; \u0026quot;reflect\u0026quot; ) func main() { rv := []interface{}{\u0026quot;hi\u0026quot;, 42, func() {}} for _, v := range rv { switch v := reflect.ValueOf(v); v.Kind() { case reflect.String: fmt.Println(v.String()) case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64: fmt.Println(v.Int()) default: fmt.Printf(\u0026quot;unhandled kind %s\u0026quot;, v.Kind()) } } } 输出结果：\nhi 42 unhandled kind func 在程序中主要是声明了 rv 变量，变量类型为 interface{}，其包含 3 个不同类型的值，分别是字符串、数字、闭包。一般 interface{} 的使用常见于不知道入参者具体的基本类型是什么，那么就会用 interface{} 类型来做一个伪 “泛型”。\n这时候又会引出一个新的问题，既然入参是 interface{}，那么出参时呢？ Go 语言是强类型语言，入参是 interface{}，出参也肯定是跑不了的，因此必然离不开类型的判断，这时候就要用到反射，也就是 reflect 标准库。反射过后又再进行 (type) 的类型断言。\n这就是我们在编写程序时最常遇见的一个反射使用场景。\nGo reflect reflect 标准库中，最核心的莫过于 reflect.Type 和 reflect.Value 类型。而在反射中所使用的方法都围绕着这两者进行，其方法主要含义如下：\n  TypeOf 方法：用于提取入参值的类型信息。\n  ValueOf 方法：用于提取存储的变量的值信息。\n  reflect.TypeOf 演示程序：\nfunc main() { blog := Blog{\u0026quot;煎鱼\u0026quot;} typeof := reflect.TypeOf(blog) fmt.Println(typeof.String()) } 输出结果：\nmain.Blog 从输出结果中可得出 reflect.TypeOf 成功解析出 blog 变量的类型是 main.Blog，也就是连 package 都知道了。通过人识别的角度来看似乎很正常，但程序就不是这样了。\n他是怎么知道 “他” 是哪个 package 下的什么呢？我们一起追一下源码看看：\nfunc TypeOf(i interface{}) Type { eface := *(*emptyInterface)(unsafe.Pointer(\u0026amp;i)) return toType(eface.typ) } 从源码层面来看，TypeOf 方法中主要涉及三块操作，分别如下：\n  使用 unsafe.Pointer 方法获取任意类型且可寻址的指针值。\n  利用 emptyInterface 类型进行强制的 interface 类型转换。\n  调用 toType 方法转换为可供外部使用的 Type 类型。\n  而这之中信息量最大的是 emptyInterface 结构体中的 rtype 类型：\ntype rtype struct { size uintptr ptrdata uintptr hash uint32 tflag tflag align uint8 fieldAlign uint8 kind uint8 equal func(unsafe.Pointer, unsafe.Pointer) bool gcdata *byte str nameOff ptrToThis typeOff } 在使用上最重要的是 rtype 类型，其实现了 Type 类型的所有接口方法，因此他可以直接作为 Type 类型返回，而 Type 实际上是一个接口实现，其包含了获取一个类型所必要的所有方法：\ntype Type interface { // 适用于所有类型 // 返回该类型内存对齐后所占用的字节数 Align() int // 仅作用于 strcut 类型 // 返回该类型内存对齐后所占用的字节数 FieldAlign() int // 返回该类型的方法集中的第 i 个方法 Method(int) Method // 根据方法名获取对应方法集中的方法 MethodByName(string) (Method, bool) // 返回该类型的方法集中导出的方法的数量。 NumMethod() int // 返回该类型的名称 Name() string ... } Type 接口的方法是真的多，建议大致过一遍，了解清楚有哪些方法，再针对向看就好。\n主体思想是给自己大脑建立一个索引，便于后续快速到 pkg.go.dev 上查询。\nreflect.ValueOf 演示程序：\nfunc main() { var x float64 = 3.4 fmt.Println(\u0026quot;value:\u0026quot;, reflect.ValueOf(x)) } 输出结果：\nvalue: 3.4 从输出结果中可得知通过 reflect.ValueOf 成功获取到了变量 x 的值为 3.4。与 reflect.TypeOf 形成一个相匹配，一个负责获取类型，一个负责获取值。\n那么 reflect.ValueOf 是怎么获取到值的呢，核心源码如下：\nfunc ValueOf(i interface{}) Value { if i == nil { return Value{} } escapes(i) return unpackEface(i) } func unpackEface(i interface{}) Value { e := (*emptyInterface)(unsafe.Pointer(\u0026amp;i)) t := e.typ if t == nil { return Value{} } f := flag(t.Kind()) if ifaceIndir(t) { f |= flagIndir } return Value{t, e.word, f} } 从源码层面来看，ValueOf 方法中主要涉及如下几个操作：\n  调用 escapes 让变量 i 逃逸到堆上。\n  将变量 i 强制转换为 emptyInterface 类型。\n  将所需的信息（其中包含值的具体类型和指针）组装成 reflect.Value 类型后返回。\n  何时类型转换 在调用 reflect 进行一系列反射行为时，Go 又是在什么时候进行的类型转换呢。毕竟我们传入的是 float64，而函数如参数是 inetrface 类型。\n查看汇编如下:\n$ go tool compile -S main.go ... 0x0058 00088 ($GOROOT/src/reflect/value.go:2817)\tLEAQ\ttype.float64(SB), CX 0x005f 00095 ($GOROOT/src/reflect/value.go:2817)\tMOVQ\tCX, reflect.dummy+8(SB) 0x0066 00102 ($GOROOT/src/reflect/value.go:2817)\tPCDATA\t$0, $-2 0x0066 00102 ($GOROOT/src/reflect/value.go:2817)\tCMPL\truntime.writeBarrier(SB), $0 0x006d 00109 ($GOROOT/src/reflect/value.go:2817)\tJNE\t357 0x0073 00115 ($GOROOT/src/reflect/value.go:2817)\tMOVQ\tAX, reflect.dummy+16(SB) 0x007a 00122 ($GOROOT/src/reflect/value.go:2348)\tPCDATA\t$0, $-1 0x007a 00122 ($GOROOT/src/reflect/value.go:2348)\tMOVQ\tCX, reflect.i+64(SP) 0x007f 00127 ($GOROOT/src/reflect/value.go:2348)\tMOVQ\tAX, reflect.i+72(SP) ... 显然，Go 语言会在编译阶段就会完成分析，且进行类型转换。这样子 reflect 真正所使用的就是 interface 类型了。\nreflect.Set 演示程序：\nfunc main() { i := 2.33 v := reflect.ValueOf(\u0026amp;i) v.Elem().SetFloat(6.66) log.Println(\u0026quot;value: \u0026quot;, i) } 输出结果：\nvalue: 6.66 从输出结果中，我们可得知在调用 reflect.ValueOf 方法后，我们利用 SetFloat 方法进行了值变更。核心的方法之一就是 Setter 相关的方法，我们可以一起看看其源码是怎么实现的：\nfunc (v Value) Set(x Value) { v.mustBeAssignable() x.mustBeExported() // do not let unexported x leak var target unsafe.Pointer if v.kind() == Interface { target = v.ptr } x = x.assignTo(\u0026quot;reflect.Set\u0026quot;, v.typ, target) if x.flag\u0026amp;flagIndir != 0 { typedmemmove(v.typ, v.ptr, x.ptr) } else { *(*unsafe.Pointer)(v.ptr) = x.ptr } }   检查反射对象及其字段是否可以被设置。\n  检查反射对象及其字段是否导出（对外公开）。\n  调用 assignTo 方法创建一个新的反射对象并对原本的反射对象进行覆盖。\n  根据 assignTo 方法所返回的指针值，对当前反射对象的指针进行值的修改。\n  简单来讲就是，检查是否可以设置，接着创建一个新的对象，最后对其修改。是一个非常标准的赋值流程。\n反射三大定律 Go 语言中的反射，其归根究底都是在实现三大定律：\n  Reflection goes from interface value to reflection object.\n  Reflection goes from reflection object to interface value.\n  To modify a reflection object, the value must be settable.\n  我们将针对这核心的三大定律进行介绍和说明，以此来理解 Go 反射里的各种方法是基于什么理念实现的。\n第一定律 反射的第一定律是：“反射可以从接口值（interface）得到反射对象”。\n示例代码：\nfunc main() { var x float64 = 3.4 fmt.Println(\u0026quot;type:\u0026quot;, reflect.TypeOf(x)) } 输出结果：\ntype: float64 可能有读者就迷糊了，我明明在代码中传入的变量 x，他的类型是 float64。怎么就成从接口值得到反射对象了。\n其实不然，虽然在代码中我们所传入的变量基本类型是 float64，但是 reflect.TypeOf 方法入参是 interface{}，本质上 Go 语言内部对其是做了类型转换的。这一块会在后面会进一步展开说明。\n第二定律 反射的第二定律是：“可以从反射对象得到接口值（interface）”。其与第一条定律是相反的定律，可以是互相补充了。\n示例代码：\nfunc main() { vo := reflect.ValueOf(3.4) vf := vo.Interface().(float64) log.Println(\u0026quot;value:\u0026quot;, vf) } 输出结果：\nvalue: 3.4 可以看到在示例代码中，变量 vo 已经是反射对象，然后我们可以利用其所提供的的 Interface 方法获取到接口值（interface），并最后强制转换回我们原始的变量类型。\n第三定律 反射的第三定律是：“要修改反射对象，该值必须可以修改”。第三条定律看上去与第一、第二条均无直接关联，但却是必不可少的，因为反射在工程实践中，目的一就是可以获取到值和类型，其二就是要能够修改他的值。\n否则反射出来只能看，不能动，就会造成这个反射很鸡肋。例如：应用程序中的配置热更新，必然会涉及配置项相关的变量变动，大多会使用到反射来变动初始值。\n示例代码：\nfunc main() { i := 2.33 v := reflect.ValueOf(\u0026amp;i) v.Elem().SetFloat(6.66) log.Println(\u0026quot;value: \u0026quot;, i) } 输出结果：\nvalue: 6.66 单从结果来看，变量 i 的值确实从 2.33 变成了 6.66，似乎非常完美。\n但是单看代码，似乎有些 “问题”，怎么设置一个反射值这么 ”麻烦“：\n  为什么必须传入变量 i 的指针引用？\n  为什么变量 v 在设置前还需要 Elem 一下？\n  本叛逆的 Gophper 表示我就不这么设置，行不行呢，会不会出现什么问题：\nfunc main() { i := 2.33 reflect.ValueOf(i).SetFloat(6.66) log.Println(\u0026quot;value: \u0026quot;, i) } 报错信息：\npanic: reflect: reflect.Value.SetFloat using unaddressable value goroutine 1 [running]: reflect.flag.mustBeAssignableSlow(0x8e) /usr/local/Cellar/go/1.15/libexec/src/reflect/value.go:259 +0x138 reflect.flag.mustBeAssignable(...) /usr/local/Cellar/go/1.15/libexec/src/reflect/value.go:246 reflect.Value.SetFloat(0x10b2980, 0xc00001a0b0, 0x8e, 0x401aa3d70a3d70a4) /usr/local/Cellar/go/1.15/libexec/src/reflect/value.go:1609 +0x37 main.main() /Users/eddycjy/go-application/awesomeProject/main.go:10 +0xc5 根据上述提示可知，由于使用 “使用不可寻址的值”，因此示例程序无法正常的运作下去。并且这是一个 reflect 标准库本身就加以防范了的硬性要求。\n这么做的原因在于，Go 语言的函数调用的传递都是值拷贝的，因此若不传指针引用，单纯值传递，那么肯定是无法变动反射对象的源值的。因此 Go 标准库就对其进行了逻辑判断，避免出现问题。\n因此期望变更反射对象的源值时，我们必须主动传入对应变量的指针引用，并且调用 reflect 标准库的 Elem 方法来获取指针所指向的源变量，并且最后调用 Set 相关方法来进行设置。\n总结 通过本文我们学习并了解了 Go 反射是如何使用，又是基于什么定律设计的。另外我们稍加关注，不难发现 Go 的反射都是基于接口（interface）来实现的，更进一步来讲，Go 语言中运行时的功能很多都是基于接口来实现的。\n整体来讲，Go 反射是围绕着三者进行的，分别是 Type、Value 以及 Interface，三者相辅相成，而反射本质上与 Interface​ 存在直接关系，Interface​ 这一块的内容我们也将在后续的文章进行进一步的剖析。\n"});index.add({'id':3,'href':'/posts/ch2/sync/','title':"同步原语",'content':"2.5 同步原语 sync.mutex\n"});index.add({'id':4,'href':'/posts/ch2/interface/','title':"接口",'content':"2.3 接口 自古流传着一个传言\u0026hellip;在 Go 语言面试的时候必有人会问接口（interface）的实现原理。这又是为什么？为何对接口如此执着？\n实际上，Go 语言的接口设计在整体扮演着非常重要的角色，没有他，很多程序估计都跑的不愉快。在 Go 语言的语义上，只要某个类型实现了所定义的一组方法集，则就认为其就是同一种类型，是一个东西。大家常常称其为鸭子类型（Duck typing），因为其与鸭子类型类型的定义相对吻合。\n在维基百科中，鸭子类型的谚语定义为 ”If it looks like a duck, swims like a duck, and quacks like a duck, then it probably is a duck.“，翻译过来就是 ”如果它看起来像鸭子，像鸭子一样游泳，像鸭子一样嘎嘎叫，那他就可以认为是鸭子“。\n回归到 Go 语言，在接口之下，接口又蕴含了怎么样的底层结构，其设计原理和思考又是什么呢？我们不能只看表面，接下来在这一章节中都会进行一一分析和道来。看看其深层到底是何 “物”。\n2.3.1 什么是 interface Go 语言中的接口声明：\ntype Human interface { Say(s string) error } 关键字主体为 type xxx interface，紧接着可以在方括号中编写方法集，用于声明和定义该接口所包含的方法集。\n更进一步的代码演示：\ntype Human interface { Say(s string) error } type TestA string func (t TestA) Say(s string) error { fmt.Printf(\u0026quot;煎鱼：%s\\n\u0026quot;, s) return nil } func main() { var h Human var t TestA _ = t.Say(\u0026quot;炸鸡翅\u0026quot;) h = t _ = h.Say(\u0026quot;烤羊排\u0026quot;) } 输出结果：\n煎鱼：炸鸡翅 煎鱼：烤羊排 我们在上述代码中，声明了一个名为 Human 的 interface，其包含一个 Say 方法。同时我们声明了一个 TestA 类型，也有自己的一个 Say 方法。他们两者的方法入参和出参类型均为一样。\n而与此同时，我们在主函数 main 中通过声明和赋值，成功将类型为 TestA 的变量 t 赋给了类型为 Human 的变量 h，也就是说两者只因有了个 Say 方法，在 Go 语言的编译器中就认为他们是 “一样” 的了，这也就是业界中常说的鸭子类型。\n2.3.2 数据结构 通过上面的功能代码一看，似乎 Go 语言非常优秀。一个接口，不同的类型，2 个包含相同的方法，也能够对标到一起。\n接口到底是怎么实现的呢？底层数据结构又是什么？带着问题，我们开始深挖细节之路。\n在 Go 语言中，接口的底层数据结构在运行时一共分为两类结构体（struct），分别是：\n runtime.eface 结构体：表示不包含任何方法的空接口，也称为 empty interface。 runtime.iface 结构体：表示包含方法的接口。  2.3.2.1 runtime.eface 首先我们来介绍 eface，看看 “他” 到底是何许人也。源码如下：\ntype eface struct { _type *_type data unsafe.Pointer } 其表示不包含任何方法的空接口。在结构上来讲 eface 非常简单，就两个属性，分别是 _type 和 data 属性，分别代表底层的指向的类型信息和指向的值信息指针。\n再进一步到 type 属性里看看，其包含的类型信息更多：\ntype _type struct { size uintptr ptrdata uintptr hash uint32 tflag tflag align uint8 fieldAlign uint8 kind uint8 equal func(unsafe.Pointer, unsafe.Pointer) bool gcdata *byte str nameOff ptrToThis typeOff }  size：类型的大小。 ptrdata：包含所有指针的内存前缀的大小。 hash：类型的 hash 值。此处提前计算好，可以避免在哈希表中计算。 tflag：额外的类型信息标志。此处为类型的 flag 标志，主要用于反射。 align：对应变量与该类型的内存对齐大小。 fieldAlign：对应类型的结构体的内存对齐大小。 kind：类型的枚举值。包含 Go 语言中的所有类型，例如：kindBool、kindInt、kindInt8、kindInt16 等。 equal：用于比较此对象的回调函数。 gcdata：存储垃圾收集器的 GC 类型数据。  总结一句，就是类型信息所需的信息都会存储在这里面，其中包含字节大小、类型标志、内存对齐、GC 等相关属性。而在 eface 来讲，其由于没有方法集的包袱，因此只需要存储类型和值信息的指针即可，非常简单。\n2.3.2.2 runtime.iface 其次就是我们日常在应用程序中应用的较多的 iface，源码如下：\ntype iface struct { tab *itab data unsafe.Pointer } 与 eface 结构体类型一样，主要也是分为类型和值信息，分别对应 tab 和 data 属性。但是我们再加思考一下，为什么 iface 能藏住那么多的方法集呢，难道施了黑魔法？\n为了解密，我们进一步深入看看 itab 结构体。源码如下：\ntype itab struct { inter *interfacetype _type *_type hash uint32 _ [4]byte fun [1]uintptr }  inter：接口的类型信息。 _type：具体类型信息 hash：_type.hash 的副本，用于目标类型和接口变量的类型对比判断。 fun：底层数组，存储接口的方法集的具体实现的地址，其包含一组函数指针，实现了接口方法的动态分派，且每次在接口发生变更时都会更新。  对应 func 属性会在后面的章节进一步展开讲解，便于大家对于接口中的函数指针管理的使用和理解，在此可以先行思考长度为 1 的 uintptr 数组是如何做到存储多方法的？\n接下来我们进一步展开 interfacetype 结构体。源码如下：\ntype nameOff int32 type typeOff int32 type imethod struct { name nameOff ityp typeOff } type interfacetype struct { typ _type pkgpath name mhdr []imethod }  _type：接口的具体类型信息。 pkgpath：接口的包（package）名信息。 mhdr：接口所定义的函数列表。  而相对应 interfacetype，还有各种类型的 type。例如：maptype、arraytype、chantype、slicetype 等，都是针对具体的类型做的具体类型定义：\ntype arraytype struct { typ _type elem *_type slice *_type len uintptr } type chantype struct { typ _type elem *_type dir uintptr } ... 若有兴趣自行翻看 runtime 里相应源码即可，都是一些基本数据结构信息的存储和配套方法，就不在此一一展开讲解了。\n2.3.2.3 小结 总结来讲，接口的数据结构基本表示形式比较简单，就是类型和值描述。再根据其具体的区别，例如是否包含方法集，具体的接口类型等进行组合使用。\n2.3.3 值接收者和指针接收者 在接口的具体应用使用场景中，有一个是大家常常会碰到，甚至会对其产生较大纠结心里的东西。那就是到底用值接收者，又或是用指针接收者来声明。\n2.3.3.1 演示说明 演示代码如下：\ntype Human interface { Say(s string) error Eat(s string) error } type TestA struct{} func (t TestA) Say(s string) error { fmt.Printf(\u0026quot;说煎鱼：%s\\n\u0026quot;, s) return nil } func (t *TestA) Eat(s string) error { fmt.Printf(\u0026quot;吃煎鱼：%s\\n\u0026quot;, s) return nil } func main() { var h Human = \u0026amp;TestA{} _ = h.Say(\u0026quot;催更\u0026quot;) _ = h.Eat(\u0026quot;真香\u0026quot;) } 在 Human 接口中，其包含 Say 和 Eat 方法，并且在 TestA 结构体中我们进行了针对性的实现。\n具体的区别就是：\n 在 Say 方法中是值接收对象，如：(t TestA)。 在 Eat 方法中是指针接收对象，如：(t *TestA)。  最终的输出结果：\n说煎鱼：催更 吃煎鱼：真香 2.3.3.2 值和指针 如果我们将演示代码的主函数 main 改成下述这样：\nfunc main() { var h Human = TestA{} _ = h.Say(\u0026quot;催更\u0026quot;) _ = h.Eat(\u0026quot;真香\u0026quot;) } 你觉得这段代码还能正常运行吗？在编译时会出现如下报错信息：\n# command-line-arguments ./main.go:23:6: cannot use TestA literal (type TestA) as type Human in assignment: TestA does not implement Human (Eat method has pointer receiver) 显然是不能的。因为接口校验不对，编译器过不了。其根本原因在于 Eat 是指针接收者。而当声明改为 TestA{} 后，其就会变成值对象，所以不匹配。\n这时候又会出现新的问题，为什么在上面代码声明为 \u0026amp;TestA{} 时，那肯定是指针引用了，那为什么 Say 方法又能正常运行，不会报错呢？\n其实 TestA{} 实现了 Say 方法，那么 \u0026amp;TestA{} 也能自动拥有该方法。显然，这是 Go 语言自身在背后做了一些事情。\n因此如果我们实现了一个值对象的接收者时，也会相应拥有了一个指针接收者。两者并不会互相影响，因为值对象会产生值拷贝，对象会独立开来。\n而指针对象的接收者不行，因为指针引用的对象，在应用上是期望能够直接对源接收者的值进行修改，若又支持值接收者，显然是不符合其语义的。\n2.3.3.3 两者怎么用 既然支持值接收，又支持指针接收。那平时在工程应用开发中，到底用谁？还是说随便用？\n其实问题的答案，在前面就有提到。本质上还是要看你业务逻辑所期望修改的是什么？还是说程序很严谨，每次都重新 new 一个，是值又或是指针引用对于程序逻辑的结果都没有任何的影响。\n总结一下，如果你想使用指针接收者，可以想想是否有以下诉求：\n 期望接收者直接修改能够直接修改源值。 期望在大结构体的情况下，性能更好，可以在理论上避免每次值拷贝，但也会有增加别的开销，需要具体情况具体权衡。  但若应用场景没什么区别，只是个人习惯问题就不用过于纠结了，适度统一也是很重要的一环。\n2.3.4 类型断言 在 Go 语言中使用接口，必搭配一个 “技能”。那就是进行类型断言（type assertion）：\nvar i interface{} = \u0026quot;吃煎鱼\u0026quot; // 进行变量断言，若不判断容易出现 panic s := i.(string) // 进行安全断言 s, ok := i.(string) 在 switch case 中，还有另外一种写法：\nvar i interface{} = \u0026quot;炸煎鱼\u0026quot; // 进行 switch 断言 switch i.(type) { case string: // do something... case int: // do something... case float64: // do something... } 采取的是 (变量).(type) 的调用方式，再给予 case 不同的类型进行判断识别。在 Go 语言的背后，类型断言其实是在编译器翻译后，根据 iface 和 eface 分别对应了下述方法：\nfunc assertI2I2(inter *interfacetype, i iface) (r iface, b bool) { tab := i.tab if tab == nil { return } if tab.inter != inter { tab = getitab(inter, tab._type, true) if tab == nil { return } } r.tab = tab r.data = i.data b = true return } func assertI2I(inter *interfacetype, i iface) (r iface) func assertE2I2(inter *interfacetype, e eface) (r iface, b bool) func assertE2I(inter *interfacetype, e eface) (r iface) 主要是根据接口的类型信息进行一轮判断和识别，基本就完成了。主要核心在于 getitab 方法，会在后面进行统一介绍和说明。\n2.3.5 类型转换 演示代码如下：\nfunc main() { x := \u0026quot;煎鱼\u0026quot; var v interface{} = x fmt.Println(v) } 查看汇编代码：\n\t0x0021 00033 (main.go:9)\tLEAQ\tgo.string.\u0026quot;煎鱼\u0026quot;(SB), AX 0x0028 00040 (main.go:9)\tMOVQ\tAX, (SP) 0x002c 00044 (main.go:9)\tMOVQ\t$6, 8(SP) 0x0035 00053 (main.go:9)\tPCDATA\t$1, $0 0x0035 00053 (main.go:9)\tCALL\truntime.convTstring(SB) 0x003a 00058 (main.go:9)\tMOVQ\t16(SP), AX 0x003f 00063 (main.go:10)\tXORPS\tX0, X0 主要对应了 runtime.convTstring 方法。同时很显然其是根据类型来区分来方法：\nfunc convTstring(val string) (x unsafe.Pointer) { if val == \u0026quot;\u0026quot; { x = unsafe.Pointer(\u0026amp;zeroVal[0]) } else { x = mallocgc(unsafe.Sizeof(val), stringType, true) *(*string)(x) = val } return } func convT16(val uint16) (x unsafe.Pointer) func convT32(val uint32) (x unsafe.Pointer) func convT64(val uint64) (x unsafe.Pointer) func convTstring(val string) (x unsafe.Pointer) func convTslice(val []byte) (x unsafe.Pointer) func convT2Enoptr(t *_type, elem unsafe.Pointer) (e eface) func convT2I(tab *itab, elem unsafe.Pointer) (i iface) ... 2.3.6 动态分派 前面有提到接口中的 fun [1]uintptr 属性会可以存储接口的方法集，但不知道为什么。\n接下来我们将进行具体的分析，演示代码：\ntype Human interface { Say(s string) error Eat(s string) error Walk(s string) error } type TestA string func (t TestA) Say(s string) error { fmt.Printf(\u0026quot;煎鱼：%s\\n\u0026quot;, s) return nil } func (t TestA) Eat(s string) error { fmt.Printf(\u0026quot;煎鱼：%s\\n\u0026quot;, s) return nil } func (t TestA) Walk(s string) error { fmt.Printf(\u0026quot;煎鱼：%s\\n\u0026quot;, s) return nil } func main() { var h Human var t TestA h = t _ = h.Eat(\u0026quot;烤羊排\u0026quot;) _ = h.Say(\u0026quot;炸鸡翅\u0026quot;) _ = h.Walk(\u0026quot;去炸鸡翅\u0026quot;) } 2.3.6.1 存储方式 执行 go build -gcflags '-l' -o awesomeProject . 编译后，再次执行 go tool objdump -s \u0026quot;main\u0026quot; awesomeProject。\n查看具体的汇编代码：\n LEAQ go.itab.main.TestA,main.Human(SB), AX\tTESTB AL, 0(AX)\tMOVQ 0x10(SP), AX\tMOVQ AX, 0x28(SP)\tMOVQ go.itab.main.TestA,main.Human+32(SB), CX\tMOVQ AX, 0(SP)\tLEAQ go.string.*+3048(SB), DX\tMOVQ DX, 0x8(SP)\tMOVQ $0x9, 0x10(SP)\tCALL CX\tMOVQ go.itab.main.TestA,main.Human+24(SB), AX\tMOVQ 0x28(SP), CX\tMOVQ CX, 0(SP)\tLEAQ go.string.*+3057(SB), DX\tMOVQ DX, 0x8(SP)\tMOVQ $0x9, 0x10(SP)\tCALL AX\tMOVQ go.itab.main.TestA,main.Human+40(SB), AX\tMOVQ 0x28(SP), CX\tMOVQ CX, 0(SP)\tLEAQ go.string.*+4973(SB), CX\tMOVQ CX, 0x8(SP)\tMOVQ $0xc, 0x10(SP)\tCALL AX\t结合来看，虽然 fun 属性的类型是 [1]uintptr，只有一个元素，但其实就是存放了接口方法集的首个方法的地址信息,接着根据顺序往后计算并获取就好了。也就是说其是存在一定规律的。在存入方法时就决定了，所以获取也能明确。\n我们进一步展开，看看 itab hash table 是如何获取和新增的。\n2.3.6.2 获取 itab 元素 getitab 方法的主要作用是获取 itab 元素，若不存在则新增。源码如下：\nfunc getitab(inter *interfacetype, typ *_type, canfail bool) *itab { // 省略一些边界、异常处理 var m *itab t := (*itabTableType)(atomic.Loadp(unsafe.Pointer(\u0026amp;itabTable))) if m = t.find(inter, typ); m != nil { goto finish } lock(\u0026amp;itabLock) if m = itabTable.find(inter, typ); m != nil { unlock(\u0026amp;itabLock) goto finish } m = (*itab)(persistentalloc(unsafe.Sizeof(itab{})+uintptr(len(inter.mhdr)-1)*sys.PtrSize, 0, \u0026amp;memstats.other_sys)) m.inter = inter m._type = typ m.hash = 0 m.init() itabAdd(m) unlock(\u0026amp;itabLock) finish: if m.fun[0] != 0 { return m } panic(\u0026amp;TypeAssertionError{concrete: typ, asserted: \u0026amp;inter.typ, missingMethod: m.init()}) }  调用 atomic.Loadp 方法加载并查找现有的 itab hash table，看看是否是否可以找到所需的 itab 元素。 若没有找到，则调用 lock 方法对 itabLock 上锁，并进行重试（再一次查找）。  若找到，则跳到 finish 标识的收尾步骤。 若没有找到，则新生成一个 itab 元素，并调用 itabAdd 方法新增到全局的 hash table 中。   返回 fun 属性的首位地址，继续后续业务逻辑。  2.3.6.3 新增 itab 元素 itabAdd 方法的主要作用是将所生成好的 itab 元素新增到 itab hash table 中。源码如下：\nfunc itabAdd(m *itab) { // 省略一些边界、异常处理 t := itabTable if t.count \u0026gt;= 3*(t.size/4) { // 75% load factor t2 := (*itabTableType)(mallocgc((2+2*t.size)*sys.PtrSize, nil, true)) t2.size = t.size * 2 iterate_itabs(t2.add) if t2.count != t.count { throw(\u0026quot;mismatched count during itab table copy\u0026quot;) } atomicstorep(unsafe.Pointer(\u0026amp;itabTable), unsafe.Pointer(t2)) t = itabTable } t.add(m) }  检查 itab hash table 的容量情况，查看容量情况是否已经满足大于或等于 75%。 若满足扩容策略，则调用 mallocgc 方法申请内存，按既有 size 大小扩容双倍容量。 若不满足扩容策略，则直接新增 itab 元素到 hash table 中。  2.3.7 总结 在本文中，我们先介绍了 Go 语言接口的 runtime.eface 和 runtime.iface 两个基本数据结构，其代表了一切的开端。随后针对值接受者和指针接收者进行了详细的说明，同时日常用的较多的类型断言和转换也一一进行了描述。\n最后对接口的多方法这个神秘的地方进行了基本分析和了解，相信这一番轮流吸收下来，能够打开大家对接口的一个新的理解。\n"});index.add({'id':5,'href':'/posts/ch2/startup/','title':"第二章：运行时",'content':"第二章：运行时 "});index.add({'id':6,'href':'/posts/ch2/timer/','title':"计时器",'content':"2.6 计时器 在实际的应用工程中，我们常常会需要多久后，或定时去做某个事情。甚至在分析标准库 context 的父子级传播时，都能见到等待多久后自动触发取消事件的踪影。\n而在 Go 语言中，能够完成这类运行的功能诉求就是标准库 time，在具体的功能范畴上我们称其为 “计时器“，是一个非常具有价值的一个模块。在这篇文章中我们将对其做进一步的分析和研讨。\n2.6.1 什么是 timer 可以控制时间，确保应用程序中的某段代码在某个时刻运行。在 Go 语言中可以单次执行，也可以循环执行。最常见的方式就是引用标准库 time 去做一些事情。普通开发者最常见的代码就是：\ntime.Now().Unix() 上述代码可用于获取当前时间的 Unix 时间戳，而在内部的具体实现上提供了 Time、Timer 以及 Ticker 的各类配套方法。\n2.6.2 timer 基本特性 2.6.2.1 Timer 演示代码：\nfunc main() { timer := time.NewTimer(2 * time.Second) \u0026lt;-timer.C fmt.Println(\u0026quot;我的脑子真的进煎鱼了！\u0026quot;) } 输出结果：\n// 等待两秒... 我的脑子真的进煎鱼了！ 我们可以通过 time.NewTimer 方法定时在 2 秒进行程序的执行。而其还有个变种的用法，在做 channel 的源码剖析时有发现\nfunc main() { v := make(chan struct{}) timer := time.AfterFunc(2*time.Second, func() { fmt.Println(\u0026quot;我想在这个点吃煎鱼！\u0026quot;) v \u0026lt;- struct{}{} }) defer timer.Stop() \u0026lt;-v } 在等待 2 秒后，会立即调用 time.AfterFunc 所对应的匿名方法。在时间上我们也可以指定对应的具体时间，达到异步的定时执行等诉求。\n2.6.2.2 Ticker 演示代码：\nfunc main() { ticker := time.NewTicker(time.Second) defer ticker.Stop() done := make(chan bool) go func() { time.Sleep(10 * time.Second) done \u0026lt;- true }() for { select { case \u0026lt;-done: fmt.Println(\u0026quot;Done!\u0026quot;) return case t := \u0026lt;-ticker.C: fmt.Println(\u0026quot;炸煎鱼: \u0026quot;, t.Unix()) } } } 输出结果：\n// 每隔一秒输出一次 炸煎鱼: 1611666168 炸煎鱼: 1611666169 炸煎鱼: 1611666170 炸煎鱼: 1611666171 ... 我们通过 time.NewTicker 方法设定每 1 秒执行一次方法，因此在 for-select 中，我们会每 1 秒就可以自动 “炸一条煎鱼”，真是快乐极了。\n而由于我们在 goroutine 中通过 sleep 方法的设定了 done 变量的输入，因此在 10 秒后就会结束炸煎鱼的循环输出，最终退出。\n2.6.3 最小堆：四叉堆 在 Go 语言中，内置计时器的数据结构都会涉及到最小四叉堆，如下图所示：\n整体来讲就是父节点一定比其子节点小，子节点之间没有任何关系和大小的要求。\n2.6.4 数据结构 在 Go 语言中每个计时器运行时的基本单元是 runtime.timer：\ntype timer struct { pp puintptr when int64 period int64 f func(interface{}, uintptr) arg interface{} seq uintptr nextwhen int64 status uint32 }  pp：计时器所在的处理器 P 的指针地址。 when：计时器被唤醒的时间。 period：计时器再次被唤醒的时间（when+period）。 f：回调函数，每次在计时器被唤醒时都会调用。 arg：回调函数的参数，每次在计时器被唤醒时会将该参数项传入回调函数 f 中。 seq：回调函数的参数，该参数仅在 netpoll 的应用场景下使用。 nextwhen：当计时器状态为 timerModifiedXX 时，将会使用 nextwhen 的值设置到 where 字段上。 status：计时器的当前状态值，计时器本身包含大量的枚举标识，这块会在后面介绍。  但这类基本单元都不会是对用户端暴露的结构体，在对外上我们直观见的最多的是 time.NewTimer 所创建的 Timer 结构体：\ntype Timer struct { C \u0026lt;-chan Time r runtimeTimer }  C：用于接收 Timer 所触发的事件，当计时器的消息事件（例如：到期）发生时，该 channel 会接收到通知。 r：与 runtime.timer 作用类似，内在属性保持一致。  同时在计时器运行模式上自 Go1.14 起发生了变更，runtime.timer 改为将每个 timer 均存储在对应的处理器 P 中\ntype p struct { ... timersLock mutex timers []*timer ... } 在处理器 P 上，timers 字段就是一个以最小四叉堆形式存储的媒介。在时序上，需要立刻执行，或说需要越早执行的，就越排在堆的越上面：\n2.6.5 实现原理 在了解了计时器的基本特性和数据结构后，我们进一步展开，一层层剖析其原理，看看其是何物。在 Go 语言中，计时器在运行时涉及十种状态处理，分别涉及增、删、改以及重置等操作。\n计时器所包含的状态如下：\n   状态名 含义     timerNoStatus 计时器尚未设置状态   timerWaiting 等待计时器启动   timerRunning 运行计时器的回调方法   timerDeleted 计时器已经被删除，但仍然在某些 P 的堆中   timerRemoving 计时器即将被删除   timerRemoved 计时器已经停止，且不在任何 P 的堆中   timerModifying 计时器正在被修改   timerModifiedEarlier 计时器已被修改为更早的时间   timerModifiedLater 计时器已被修改为更晚的时间   timerMoving 计时器已经被修改，正在被移动    这时候可能就会有小伙伴疑惑，各种启动、删除、停止、启动是指代的是什么意思？为什么会涉及到 P 的管理？\n2.6.5.1 创建计时器 接下来我们依然是从 NewTimer 和 NewTicker 方法开始入手：\nfunc NewTimer(d Duration) *Timer { c := make(chan Time, 1) t := \u0026amp;Timer{ C: c, r: runtimeTimer{ when: when(d), f: sendTime, arg: c, }, } startTimer(\u0026amp;t.r) return t } 在该方法中，其主要包含如下动作：\n 创建 Timer 对象，主要是 C 和 r 属性，含义与前面所表述的一致。 调用 startTimer 方法，启动计时器。  NewTicker 方法与 NewTimer 类似，主要是增加了 period 字段：\nfunc NewTicker(d Duration) *Ticker { c := make(chan Time, 1) t := \u0026amp;Ticker{ C: c, r: runtimeTimer{ when: when(d), period: int64(d), f: sendTime, arg: c, }, } startTimer(\u0026amp;t.r) return t } 在 Ticker 结构体中，period 字段用于表示计时器再次被唤醒的时间，可以便于做轮询触发。\n2.6.5.2 启动计时器 在前面调用 NewTimer、NewTicker 方法时，会将新创建的新计时器 timer 加入到创建 timer 的 P 的最小堆中：\nfunc addtimer(t *timer) { if t.when \u0026lt; 0 { t.when = maxWhen } if t.status != timerNoStatus { throw(\u0026quot;addtimer called with initialized timer\u0026quot;) } t.status = timerWaiting when := t.when pp := getg().m.p.ptr() lock(\u0026amp;pp.timersLock) cleantimers(pp) doaddtimer(pp, t) unlock(\u0026amp;pp.timersLock) wakeNetPoller(when) }  检查是否满足基本条件：新增计时器的边界处理，timerNoStatus 状态判断排除。 调用 cleantimers 方法：清理处理器 P 中的计时器队列，可以加快创建和删除计时器的程序的速度。 调用 doaddtimer 方法：将当前所新创建的 timer 新增到当前处理器 P 的堆中。 调用 wakeNetPoller 方法：唤醒网络轮询器中休眠的线程，检查计时器被唤醒的时间（when）是否在当前轮询预期运行的时间（pollerPollUntil）内，若是唤醒。  2.6.5.3 停止计时器 在计时器的运转中，一般会调用 timer.Stop() 方法来停止/终止/删除计时器。虽然说法多样。但大家的真实目的是一样的，就是让这个 timer 从轮询器中消失，也就是从处理器 P 的堆中移除 timer：\nfunc deltimer(t *timer) bool { for { switch s := atomic.Load(\u0026amp;t.status); s { case timerWaiting, timerModifiedLater: // timerWaiting/timerModifiedLater -\u0026gt; timerDeleted ... case timerModifiedEarlier: // timerModifiedEarlier -\u0026gt; timerModifying -\u0026gt; timerDeleted ... case timerDeleted, timerRemoving, timerRemoved: // timerDeleted/timerRemoving/timerRemoved return false case timerRunning, timerMoving: // timerRunning/timerMoving osyield() case timerNoStatus: return false case timerModifying: osyield() default: badTimer() } } } 但移除也不是直接一个 delete 就完事的，其在真正的删除方法 deltimer 中遵循了基本的规则处理：\n timerWaiting/timerModifiedLater -\u0026gt; timerDeleted。 timerModifiedEarlier -\u0026gt; timerModifying -\u0026gt; timerDeleted。 timerDeleted/timerRemoving/timerRemoved -\u0026gt; 无需变更，已经满足条件。 timerRunning/timerMoving/timerModifying -\u0026gt; 正在执行、移动中，无法停止，等待下一次状态检查再处理。 timerNoStatus -\u0026gt; 无法停止，不满足条件。  上述五个基本流转逻辑就覆盖了 runtimer.deltimer 方法了，若有进一步需求的可通过传送门详细阅读。\n2.6.5.4 修改/重置计时器 在应用程序的调度中，有时候因为逻辑产生了变更，我们需要重置计时器。这时候一般会调用 timer.Reset() 方法来重新设置 Duration 值。\n其表面对应的是 resetTimer 方法，但实际与修改计时器的 modtimer 方法是共用的：\nfunc resettimer(t *timer, when int64) bool { return modtimer(t, when, t.period, t.f, t.arg, t.seq) } 因此在这节中我们可以将重置和修改计时器放在一起分析。修改计时器，本质上是需要变更现有计时器，而在 Go 语言的计时器中是需要遵循基本规则，因此 modtimer 遵循下述规则处理：\n timerWaiting -\u0026gt; timerModifying -\u0026gt; timerModifiedXX timerModifiedXX -\u0026gt; timerModifying -\u0026gt; timerModifiedYY timerNoStatus -\u0026gt; timerModifying -\u0026gt; timerWaiting timerRemoved -\u0026gt; timerModifying -\u0026gt; timerWaiting timerDeleted -\u0026gt; timerModifying -\u0026gt; timerModifiedXX timerRunning -\u0026gt; 等待状态改变，才可以进行下一步 timerMoving -\u0026gt; 等待状态改变，才可以进行下一步 timerRemoving -\u0026gt; 等待状态改变，才可以进行下一步 timerModifying -\u0026gt; 等待状态改变，才可以进行下一步  func modtimer(t *timer, when, period int64, f func(interface{}, uintptr), arg interface{}, seq uintptr) bool { ... if wasRemoved { t.when = when pp := getg().m.p.ptr() lock(\u0026amp;pp.timersLock) doaddtimer(pp, t) unlock(\u0026amp;pp.timersLock) releasem(mp) wakeNetPoller(when) } else { t.nextwhen = when newStatus := uint32(timerModifiedLater) if when \u0026lt; t.when { newStatus = timerModifiedEarlier } ... releasem(mp) if newStatus == timerModifiedEarlier { wakeNetPoller(when) } } return pending } 在完成了计时器的状态处理后，会分为两种情况处理：\n 待修改的计时器已经被删除：由于既有的计时器已经没有了，因此会调用 doaddtimer 方法创建一个新的计时器，并将原本的 timer 属性赋值过去，再调用 wakeNetPoller 方法在预定时间唤醒网络轮询。 正常逻辑处理：如果修改后的计时器的触发时间小于原本的触发时间，则修改该计时器的状态为 timerModifiedEarlier，并且调用 wakeNetPoller 方法在预定时间唤醒网络轮询。  2.6.5.5 触发计时器 在前面有提到 Go1.14 后，Go Timer 都已经归属到各个处理器 P 中去了，因此计时器的触发分为了两个部分：\n 通过调度器在调度时进行计时器的触发。 通过系统监控检查并触发计时器（到期未执行）。  2.6.5.5.1 调度器触发 调度器的触发一共分两种情况，一种是在调度循环的时候调用 checkTimers 方法进行计时器的触发：\nfunc schedule() { _g_ := getg() top: pp := _g_.m.p.ptr() pp.preempt = false // 处理调度时的计时器触发 checkTimers(pp, 0) ... execute(gp, inheritTime) } 另外一种是当前处理器 P 没有可执行的 Timer，且没有可执行的 G。那么按照调度模型，就会去窃取其他计时器和 G：\nfunc findrunnable() (gp *g, inheritTime bool) { _g_ := getg() top: _p_ := _g_.m.p.ptr() ... now, pollUntil, _ := checkTimers(_p_, 0) ... } 调度系统在计时器处不深究，我们进一步剖析具体触发计时器的 checkTimers 方法：\nfunc checkTimers(pp *p, now int64) (rnow, pollUntil int64, ran bool) { if atomic.Load(\u0026amp;pp.adjustTimers) == 0 { next := int64(atomic.Load64(\u0026amp;pp.timer0When)) if next == 0 { return now, 0, false } if now == 0 { now = nanotime() } if now \u0026lt; next { if pp != getg().m.p.ptr() || int(atomic.Load(\u0026amp;pp.deletedTimers)) \u0026lt;= int(atomic.Load(\u0026amp;pp.numTimers)/4) { return now, next, false } } } lock(\u0026amp;pp.timersLock) adjusttimers(pp) ... }  起始先通过 pp.adjustTimers 检查当前处理器 P 中是否有需要处理的计时器。  若无需执行的计时器，则直接返回。 若有，则判断下一个计时器待删除的计时器和处理器 P 上的计时器数量，若前者小于后者 1/4 则直接返回。   确定需要处理计时器后，通过调用 adjusttimers 方法重新根据时间将 timers 切片中 timer 的先后顺序重新排列（相当于 resort）。  func checkTimers(pp *p, now int64) (rnow, pollUntil int64, ran bool) { ... rnow = now if len(pp.timers) \u0026gt; 0 { if rnow == 0 { rnow = nanotime() } for len(pp.timers) \u0026gt; 0 { if tw := runtimer(pp, rnow); tw != 0 { if tw \u0026gt; 0 { pollUntil = tw } break } ran = true } } ... } 在前面调整了 timers 切片中的最小堆的排序后，将会调用 runtimer 方法去真正运行所需要执行的 timer，完成触计时器的发。\nfunc checkTimers(pp *p, now int64) (rnow, pollUntil int64, ran bool) { ... if pp == getg().m.p.ptr() \u0026amp;\u0026amp; int(atomic.Load(\u0026amp;pp.deletedTimers)) \u0026gt; len(pp.timers)/4 { clearDeletedTimers(pp) } unlock(\u0026amp;pp.timersLock) return rnow, pollUntil, ran } 在最后扫尾阶段，如果当前 G 的处理器与调用 checkTimers 方法所传入的处理器一致，并且处理器中 timerDeleted 状态的计时器数量是处理器 P 堆中的计时器的 1/4 以上，则调用 clearDeletedTimers 方法对已为删除状态的的计时器进行清理。\n2.6.5.5.2 系统监控触发 即使是通过每次调度器调度和窃取的时候触发，但毕竟是具有一定的随机和不确定性。\n因此系统监控触发依然是一个兜底保障，在 Go 语言中 runtime.sysmon 方法承担了这一个责任，存在触发计时器的逻辑：\nfunc sysmon() { ... for { ... next, _ := timeSleepUntil() if debug.schedtrace \u0026lt;= 0 \u0026amp;\u0026amp; (sched.gcwaiting != 0 || atomic.Load(\u0026amp;sched.npidle) == uint32(gomaxprocs)) { lock(\u0026amp;sched.lock) if atomic.Load(\u0026amp;sched.gcwaiting) != 0 || atomic.Load(\u0026amp;sched.npidle) == uint32(gomaxprocs) { if next \u0026gt; now { ... next, _ = timeSleepUntil() lock(\u0026amp;sched.lock) atomic.Store(\u0026amp;sched.sysmonwait, 0) noteclear(\u0026amp;sched.sysmonnote) } idle = 0 delay = 20 } unlock(\u0026amp;sched.lock) } ... } } 在每次进行系统监控时，都会在流程上调用 timeSleepUntil 方法去获取下一个计时器应触发的时间，以及保存该计时器已打开的计时器堆的 P。\n在获取完毕后会马上检查当前是否存在 GC，若是正在 STW 则获取调度互斥锁。若发现下一个计时器的触发时间已经过去，则重新调用 timeSleepUntil 获取下一个计时器的时间和相应 P 的地址。\nfunc sysmon() { ... for { ... lock(\u0026amp;sched.sysmonlock) { now1 := nanotime() if now1-now \u0026gt; 50*1000 /* 50µs */ { next, _ = timeSleepUntil() } now = now1 } ... } } 检查 sched.sysmonlock 所花费的时间是否超过 50µs。若是，则有可能前面所获取的下一个计时器触发时间已过期，因此重新调用 timeSleepUntil 方法再次获取。\nfunc sysmon() { ... for { ... lastpoll := int64(atomic.Load64(\u0026amp;sched.lastpoll)) if netpollinited() \u0026amp;\u0026amp; lastpoll != 0 \u0026amp;\u0026amp; lastpoll+10*1000*1000 \u0026lt; now { atomic.Cas64(\u0026amp;sched.lastpoll, uint64(lastpoll), uint64(now)) list := netpoll(0) // non-blocking - returns list of goroutines if !list.empty() { incidlelocked(-1) injectglist(\u0026amp;list) incidlelocked(1) } } if next \u0026lt; now { startm(nil, false) } } } 如果发现超过 10ms 的时间没有进行 netpoll 网络轮询，则主动调用 netpoll 方法触发轮询。\n同时如果存在不可抢占的处理器 P，则调用 startm 方法来运行那些应该运行，但没有在运行的计时器。\n2.6.5.6 运行计时器 runtimer 方法主要承担计时器的具体运行，同时也会针对计时器的不同状态（含删除、修改、等待等）都进行了对应的处理，也相当于是个大的集中处理中枢了。例如在 timerDeleted 状态下的计时器将会进行删除。\n其遵循下述规则处理\n timerNoStatus -\u0026gt; 恐慌：计时器未初始化 timerWaiting -\u0026gt; timerWaiting timerWaiting -\u0026gt; timerRunning -\u0026gt; timerNoStatus timerWaiting -\u0026gt; timerRunning -\u0026gt; timerWaiting timerModifying -\u0026gt; 等待状态改变，才可以进行下一步 timerModifiedXX -\u0026gt; timerMoving -\u0026gt; timerWaiting timerDeleted -\u0026gt; timerRemoving -\u0026gt; timerRemoved timerRunning -\u0026gt; 恐慌：并发调用 timerRemoved -\u0026gt; 恐慌：计时器堆不一致 timerRemoving -\u0026gt; 恐慌：计时器堆不一致 timerMoving -\u0026gt; 恐慌：计时器堆不一致  func runtimer(pp *p, now int64) int64 { for { t := pp.timers[0] switch s := atomic.Load(\u0026amp;t.status); s { case timerWaiting: if t.when \u0026gt; now { return t.when } runOneTimer(pp, t, now) return 0 case timerDeleted: ... case timerModifiedEarlier, timerModifiedLater: ... case timerModifying: osyield() case timerNoStatus, timerRemoved: badTimer() case timerRunning, timerRemoving, timerMoving: badTimer() default: badTimer() } } } 由于是运行，我们集中看 timerWaiting 状态下的处理，其首先会对触发时间（when）进行判定，若大于当前时间则直接返回（因为所需触发的时间未到）。否则将会调用 runOneTimer 方法去执行本次触发：\nfunc runOneTimer(pp *p, t *timer, now int64) { f := t.f arg := t.arg seq := t.seq if t.period \u0026gt; 0 { delta := t.when - now t.when += t.period * (1 + -delta/t.period) siftdownTimer(pp.timers, 0) if !atomic.Cas(\u0026amp;t.status, timerRunning, timerWaiting) { badTimer() } updateTimer0When(pp) } else { dodeltimer0(pp) } unlock(\u0026amp;pp.timersLock) f(arg, seq) lock(\u0026amp;pp.timersLock) }  如果 period 大于 0，说明当前是 ticker，需要再次触发，因此还需要调整计时器的状态。  重新计算下一次的触发时间，并且更新其在最小堆的位置。 调用 atomic.Cas 方法该计时器的状态从 timerRunning 原子修改为 timerWaiting 状态。 调用 updateTimer0When 方法设置处理器 P 的 timer0When 字段。   如果 period 等于 0，说明当前是 timer，只需要单次触发就可以了。  在完成计时器的运行属性更新后，上互斥锁，调用计时器的回调方法 f，完成本次完整的触发流程。\n2.6.7 总结 Go 语言的 Timer 其实已经改过了好几版，在 Go1.14 的正式大改版后。目前来看已经初步的到了一个新的阶段。其设计的模式主要围绕三块：\n 在各个处理器 P 中，Timer 以最小四叉堆的存储方式在 timers 中。 在调度器的每轮调度中都会对计时器进行触发和检查。 在系统监听上 netpoll 会定时进行计时器的触发和检查。 在计时器的处理中，十个状态的流转和对应处理非常重要。  "});index.add({'id':7,'href':'/posts/ch2/channel/','title':"通道",'content':"2.1 通道 Go 语言中的一大利器那就是能够非常方便的使用 go 关键字来进行各种并发，而并发后又必然会涉及通信。\nChannel 自然而然就成为了 Go 语言开发者中必须要明白明了的一个 “东西” 了，更别提实际工程应用和日常面试了，属于必知必会。\n什么是 channel 在 Go 语言中，channel 可以称其为通道，也可以叫管道。channel 主要常见于与 goroutine+select 搭配使用，再结合语录的描述。可以知道 channel 就是用于 goroutine 的数据通信：\n演示代码如下：\nfunc main() { ch := make(chan string) go func() { ch \u0026lt;- \u0026quot;煎鱼\u0026quot; }() msg := \u0026lt;-ch fmt.Println(msg) } 在 goroutine1 中写入 “煎鱼” 到变量 ch 中，goroutine2 监听变量 ch，并阻塞等待读取到值 “煎鱼” 最终返回，结束流程。\n在此 channel 承载着一个衔接器的桥梁：\n这也是 channel 的经典思想了，不要通过共享内存来通信，而是通过通信来实现内存共享（Do not communicate by sharing memory; instead, share memory by communicating）。\n从模式上来看，其就是在多个 goroutine 借助 channel 来传输数据，实现了跨 goroutine 间的数据传输，多者独立运行，不需要强关联，更不影响对方的 goroutine 状态。不存在 goroutine1 对 goroutine2 进行直传的情况。\n这里思考一个问题，那 goroutine1 和 goroutine2 又怎么互相知道自己的数据 ”到“ 了呢？\nchannel 基本特性 在 Go 语言中，channel 的关键字为 chan，数据流向的表现方式为 \u0026lt;-，代码解释方向是从左到右，据此就能明白通道的数据流转方向了。\nchannel 共有两种模式，分别是：双向和单向；三种表现方式，分别是：声明双向通道：chan T、声明只允许发送的通道：chan \u0026lt;- T、声明只允许接收的通道：\u0026lt;- chan T。\nchannel 中还分为 “无缓冲 channel” 和 “缓冲 channel”。\n演示代码如下：\n// 无缓冲 ch1 := make(chan int) // 缓冲区为 3 ch2 := make(chan int, 3) 接下来我们进一步展开这两类来看。\n无缓冲 channel 无缓冲的 channel（unbuffered channel），其缓冲区大小则默认为 0。在功能上其接受者会阻塞等待并阻塞应用程序，直至收到通信和接收到数据。\n这种常用于两个 goroutine 间互相同步等待的应用场景：\n（引用 William Kennedy 的图）\n缓冲 channel 有缓存的 channel（buffered channel），其缓存区大小是根据所设置的值来调整。在功能上，若缓冲区未满则不会阻塞，会源源不断的进行传输。当缓冲区满了后，发送者就会阻塞并等待。而当缓冲区为空时，接受者就会阻塞并等待，直至有新的数据：\n（引用 William Kennedy 的图）\n在实际的应用场景中，两者根据业务情况选用就可以了，不需要太过纠结于两者是否有性能差距，没意义。\nchannel 本质 channel 听起来实现了一个非常酷的东西，也是日常工作中常常会被面试官问到的问题。\n但其实 channel 并没有那么的 \u0026ldquo;神秘\u0026rdquo;，就是一个环形队列的配合。接下来我们一步步的剖开 channel，看看里面到底是什么，怎么实现的跨 goroutine 通信，数据结构又是什么，两者又如何实现数据传输的？\n基本原理 本质上 channel 在设计上就是环形队列。其包含发送方队列、接收方队列，加上互斥锁 mutex 等结构。\nchannel 是一个有锁的环形队列：\n数据结构 hchan 结构体是 channel 在运行时的具体表现形式：\n// src/runtime/chan.go type hchan struct { qcount uint dataqsiz uint buf unsafe.Pointer elemsize uint16 closed uint32 elemtype *_type sendx uint recvx uint recvq waitq sendq waitq lock mutex }  qcount：队列中的元素总数量。 dataqsiz：循环队列的长度。 buf：指向长度为 dataqsiz 的底层数组，仅有当 channel 为缓冲型的才有意义。 elemsize：能够接受和发送的元素大小。 closed：是否关闭。 elemtype：能够接受和发送的元素类型。 sendx：已发送元素在循环队列中的索引位置。 recvx：已接收元素在循环队列中的索引位置。 recvq：接受者的 sudog 等待队列（缓冲区不足时阻塞等待的 goroutine）。 sendq：发送者的 sudog 等待队列。  在数据结构中，我们可以看到 recvq 和 sendq，其表现为等待队列，其类型为 runtime.waitq 的双向链表结构：\ntype waitq struct { first *sudog last *sudog } 且无论是 first 属性又或是 last，其类型都为 runtime.sudog 结构体：\ntype sudog struct { g *g next *sudog prev *sudog elem unsafe.Pointer ... }  g：指向当前的 goroutine。 next：指向下一个 g。 prev：指向上一个 g。 elem：数据元素，可能会指向堆栈。  sudog 是 Go 语言中用于存放协程状态为阻塞的 goroutine 的双向链表抽象，你可以直接理解为一个正在等待的 goroutine 就可以了。\n在后续的实现原理分析中，基本围绕着上述数据结构进行大量的讨论，建议可以认真思考一下。\nchannel 实现原理 在了解了 channel 的基本原理后，我们进入到与应用工程中更紧密相关的部分，那就是 channel 的四大块操作，分别是： “创建、发送、接收、关闭”。\n我们将针对这四块进行细致的分析和讲解。因此接下来的内容比较庞大，内容上将分为两个角度来讲述，分别是先从源码角度进行分析，再进行图示汇总。以便于大家更好的理解和思考\n创建 chan 创建 channel 的演示代码：\nch := make(chan string) 其在编译器翻译后对应 runtime.makechan 或 runtime.makechan64 方法：\n// 通用创建方法 func makechan(t *chantype, size int) *hchan // 类型为 int64 的进行特殊处理 func makechan64(t *chantype, size int64) *hchan 通过前面我们得知 channel 的基本单位是 hchan 结构体，那么在创建 channel 时，究竟还需要做什么是呢？\n我们一起分析一下 makechan 方法，就能知道了。\n源码如下：\n// src/runtime/chan.go func makechan(t *chantype, size int) *hchan { elem := t.elem mem, _ := math.MulUintptr(elem.size, uintptr(size)) var c *hchan switch { case mem == 0: c = (*hchan)(mallocgc(hchanSize, nil, true)) c.buf = c.raceaddr() case elem.ptrdata == 0: c = (*hchan)(mallocgc(hchanSize+mem, nil, true)) c.buf = add(unsafe.Pointer(c), hchanSize) default: c = new(hchan) c.buf = mallocgc(mem, elem, true) } c.elemsize = uint16(elem.size) c.elemtype = elem c.dataqsiz = uint(size) lockInit(\u0026amp;c.lock, lockRankHchan) return c } 创建 channel 的逻辑主要分为三大块：\n 当前 channel 不存在缓冲区，也就是元素大小为 0 的情况下，就会调用 mallocgc 方法分配一段连续的内存空间。 当前 channel 存储的类型存在指针引用，就会连同 hchan 和底层数组同时分配一段连续的内存空间。 通用情况，默认分配相匹配的连续内存空间。  需要注意到一块特殊点，那就是 channel 的创建都是调用的 mallocgc 方法，也就是 channel 都是创建在堆上的。因此 channel 是会被 GC 回收的，自然也不总是需要 close 方法来进行显示关闭了。\n从整体上来讲，makechan 方法的逻辑比较简单，就是创建 hchan 并分配合适的 buf 大小的堆上内存空间。\n发送数据 channel 发送数据的演示代码：\ngo func() { ch \u0026lt;- \u0026quot;煎鱼\u0026quot; }() 其在编译器翻译后对应 runtime.chansend1 方法：\nfunc chansend1(c *hchan, elem unsafe.Pointer) { chansend(c, elem, true, getcallerpc()) } 其作为编译后的入口方法，实则指向真正的实现逻辑，也就是 chansend 方法。\n前置处理 在第一部分中，我们先看看 chan 发送的一些前置判断和处理：\nfunc chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool { if c == nil { if !block { return false } gopark(nil, nil, waitReasonChanSendNilChan, traceEvGoStop, 2) throw(\u0026quot;unreachable\u0026quot;) } if !block \u0026amp;\u0026amp; c.closed == 0 \u0026amp;\u0026amp; full(c) { return false } // 省略一些调试相关 ... } func full(c *hchan) bool { if c.dataqsiz == 0 { return c.recvq.first == nil } return c.qcount == c.dataqsiz } 一开始 chansend 方法在会先判断当前的 channel 是否为 nil。若为 nil，在逻辑上来讲就是向 nil channel 发送数据，就会调用 gopark 方法使得当前 Goroutine 休眠，进而出现死锁崩溃，表象就是出现 panic 事件来快速失败。\n紧接着会对非阻塞的 channel 进行一个上限判断，看看是否快速失败。\n失败的场景如下：\n 若非阻塞且未关闭，同时底层数据 dataqsiz 大小为 0（缓冲区无元素），则会返回失败。。 若是 qcount 与 dataqsiz 大小相同（缓冲区已满）时，则会返回失败。  上互斥锁 在完成了 channel 的前置判断后，即将在进入发送数据的处理前，channel 会进行上锁：\nfunc chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool { ... lock(\u0026amp;c.lock) } 上锁后就能保住并发安全。另外我们也可以考虑到，这种场景会相对依赖单元测试的覆盖，因为一旦没考虑周全，漏上锁了，基本就会出问题。\n直接发送 在正式开始发送前，加锁之后，会对 channel 进行一次状态判断（是否关闭）：\nfunc chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool { ... if c.closed != 0 { unlock(\u0026amp;c.lock) panic(plainError(\u0026quot;send on closed channel\u0026quot;)) } if sg := c.recvq.dequeue(); sg != nil { send(c, sg, ep, func() { unlock(\u0026amp;c.lock) }, 3) return true } } 这种情况是最为基础的，也就是当前 channel 有正在阻塞等待的接收方，那么只需要直接发送就可以了。\n缓冲发送 非直接发送，那么就考虑第二种场景，判断 channel 缓冲区中是否还有空间：\nfunc chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool { ... if c.qcount \u0026lt; c.dataqsiz { qp := chanbuf(c, c.sendx) typedmemmove(c.elemtype, qp, ep) c.sendx++ if c.sendx == c.dataqsiz { c.sendx = 0 } c.qcount++ unlock(\u0026amp;c.lock) return true } if !block { unlock(\u0026amp;c.lock) return false } } 会对缓冲区进行判定（qcount 和 dataqsiz 字段），以此识别缓冲区的剩余空间。紧接进行如下操作：\n 调用 chanbuf 方法，以此获得底层缓冲数据中位于 sendx 索引的元素指针值。 调用 typedmemmove 方法，将所需发送的数据拷贝到缓冲区中。 数据拷贝后，对 sendx 索引自行自增 1。同时若 sendx 与 dataqsiz 大小一致，则归 0（环形队列）。 自增完成后，队列总数同时自增 1。解锁互斥锁，返回结果。  至此针对缓冲区的数据操作完成。但若没有走进缓冲区处理的逻辑，则会判断当前是否阻塞 channel，若为非阻塞，将会解锁并直接返回失败。\n配合图示如下：\n阻塞发送 在进行了各式各样的层层筛选后，接下来进入阻塞等待发送的过程：\nfunc chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool { ... gp := getg() mysg := acquireSudog() mysg.releasetime = 0 if t0 != 0 { mysg.releasetime = -1 } mysg.elem = ep mysg.waitlink = nil mysg.g = gp mysg.isSelect = false mysg.c = c gp.waiting = mysg gp.param = nil c.sendq.enqueue(mysg) atomic.Store8(\u0026amp;gp.parkingOnChan, 1) gopark(chanparkcommit, unsafe.Pointer(\u0026amp;c.lock), waitReasonChanSend, traceEvGoBlockSend, 2) KeepAlive(ep) }  调用 getg 方法获取当前 goroutine 的指针，用于后续发送数据。 调用 acquireSudog 方法获取 sudog 结构体，并设置当前 sudog 具体的待发送数据信息和状态。 调用 c.sendq.enqueue 方法将刚刚所获取的 sudog 加入待发送的等待队列。 调用 gopark 方法挂起当前 goroutine（会记录执行位置），状态为 waitReasonChanSend，阻塞等待 channel。 调用 KeepAlive 方法保证待发送的数据值是活跃状态，也就是分配在堆上，避免被 GC 回收。  配合图示如下：\n在当前 goroutine 被挂起后，其将会在 channel 能够发送数据后被唤醒：\nfunc chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool { ... // 从这里开始唤醒，并恢复阻塞的发送操作 if mysg != gp.waiting { throw(\u0026quot;G waiting list is corrupted\u0026quot;) } gp.waiting = nil gp.activeStackChans = false if gp.param == nil { if c.closed == 0 { throw(\u0026quot;chansend: spurious wakeup\u0026quot;) } panic(plainError(\u0026quot;send on closed channel\u0026quot;)) } gp.param = nil if mysg.releasetime \u0026gt; 0 { blockevent(mysg.releasetime-t0, 2) } mysg.c = nil releaseSudog(mysg) return true } 唤醒 goroutine（调度器在停止 g 时会记录运行线程和方法内执行的位置）并完成 channel 的阻塞数据发送动作后。进行基本的参数检查，确保是符合要求的（纵深防御），接着开始取消 mysg 上的 channel 绑定和 sudog 的释放。\n至此完成所有类别的 channel 数据发送管理。\n接收数据 channel 接受数据的演示代码：\nmsg := \u0026lt;-ch msg, ok := \u0026lt;-ch 两种方法在编译器翻译后分别对应 runtime.chanrecv1 和 runtime.chanrecv2 两个入口方法，其再在内部再进一步调用 runtime.chanrecv 方法：\n需要注意，发送和接受 channel 是相对的，也就是其核心实现也是相对的。因此在理解时也可以结合来看。\n前置处理 func chanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected, received bool) { if c == nil { if !block { return } gopark(nil, nil, waitReasonChanReceiveNilChan, traceEvGoStop, 2) throw(\u0026quot;unreachable\u0026quot;) } 一开始时 chanrecv 方法会判断其是否为 nil channel。\n场景如下：\n 若 channel 是 nil channel，且为阻塞接收则调用 gopark 方法挂起当前 goroutine。 若 channel 是非阻塞模式，则直接返回。  而接下来对于非阻塞模式的 channel 会进行快速失败检查，检测 channel 是否已经准备好接收。\n\tif !block \u0026amp;\u0026amp; empty(c) { if atomic.Load(\u0026amp;c.closed) == 0 { return } if empty(c) { if ep != nil { typedmemclr(c.elemtype, ep) } return true, false } } ... } 其分以下几种情况：\n 无缓冲区：循环队列为 0 及等待队列 sendq 内没有 goroutine 正在等待。 有缓冲区：缓冲区数组为空。  随后会对 channel 的 closed 状态进行判断，因为 channel 是无法重复打开的，需要确定当前 channel 是否为未关闭状态。再确定接收失败，返回。\n但若是 channel 已经关闭且不存在缓存数据了，则会清理 ep 指针中的数据并返回。\n直接接收 当发现 channel 上有正在阻塞等待的发送方时，则直接进行接收：\nfunc chanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected, received bool) { lock(\u0026amp;c.lock) if sg := c.sendq.dequeue(); sg != nil { recv(c, sg, ep, func() { unlock(\u0026amp;c.lock) }, 3) return true, true } ... } 缓冲接收 当发现 channel 的缓冲区中有元素时：\nfunc chanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected, received bool) { if c.qcount \u0026gt; 0 { qp := chanbuf(c, c.recvx) if ep != nil { typedmemmove(c.elemtype, ep, qp) } typedmemclr(c.elemtype, qp) c.recvx++ if c.recvx == c.dataqsiz { c.recvx = 0 } c.qcount-- unlock(\u0026amp;c.lock) return true, true } if !block { unlock(\u0026amp;c.lock) return false, false } ... } 将会调用 chanbuf 方法根据 recvx 的索引位置取出数据，找到要接收的元素进行处理。若所接收到的数据和所传入的变量均不为空，则会调用 typedmemmove 方法将缓冲区中的数据拷贝到所传入的变量中。\n最后数据拷贝完毕后，进行各索引项和队列总数的自增增减，并调用 typedmemclr 方法进行内存数据的清扫。\n阻塞接收 当发现 channel 上既没有待发送的 goroutine，缓冲区也没有数据时。将会进入到最后一个阶段阻塞接收：\nfunc chanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected, received bool) { gp := getg() mysg := acquireSudog() mysg.releasetime = 0 if t0 != 0 { mysg.releasetime = -1 } mysg.elem = ep mysg.waitlink = nil gp.waiting = mysg mysg.g = gp mysg.isSelect = false mysg.c = c gp.param = nil c.recvq.enqueue(mysg) atomic.Store8(\u0026amp;gp.parkingOnChan, 1) gopark(chanparkcommit, unsafe.Pointer(\u0026amp;c.lock), waitReasonChanReceive, traceEvGoBlockRecv, 2) ... } 这一块接收逻辑与发送也基本类似，主体就是获取当前 goroutine，构建 sudog 结构保存当前待接收数据（发送方）的地址信息，并将 sudog 加入等待接收队列。最后调用 gopark 方法挂起当前 goroutine，等待唤醒。\nfunc chanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected, received bool) { // 被唤醒后从此处开始 if mysg != gp.waiting { throw(\u0026quot;G waiting list is corrupted\u0026quot;) } gp.waiting = nil gp.activeStackChans = false if mysg.releasetime \u0026gt; 0 { blockevent(mysg.releasetime-t0, 2) } closed := gp.param == nil gp.param = nil mysg.c = nil releaseSudog(mysg) return true, !closed } 被唤醒后，将恢复现场，回到对应的执行点，完成最后的扫尾工作。\n关闭 chan 关闭 channel 主要是涉及到 close 关键字：\nclose(ch) 其对应的编译器翻译方法为 closechan 方法：\nfunc closechan(c *hchan) 前置处理 func closechan(c *hchan) { if c == nil { panic(plainError(\u0026quot;close of nil channel\u0026quot;)) } lock(\u0026amp;c.lock) if c.closed != 0 { unlock(\u0026amp;c.lock) panic(plainError(\u0026quot;close of closed channel\u0026quot;)) } c.closed = 1 ... } 基本检查和关闭标志设置，保证 channel 不为 nil 和未关闭，保证边界。\n释放接收方 在完成了异常边界判断和标志设置后，会将接受者的 sudog 等待队列（recvq）加入到待清除队列 glist 中：\nfunc closechan(c *hchan) { var glist gList for { sg := c.recvq.dequeue() if sg == nil { break } if sg.elem != nil { typedmemclr(c.elemtype, sg.elem) sg.elem = nil } if sg.releasetime != 0 { sg.releasetime = cputicks() } gp := sg.g gp.param = nil if raceenabled { raceacquireg(gp, c.raceaddr()) } glist.push(gp) } ... } 所取出并加入的 goroutine 状态需要均为 _Gwaiting，以保证后续的新一轮调度。\n释放发送方 同样，与释放接收方一样。会将发送方也加入到到待清除队列 glist 中：\nfunc closechan(c *hchan) { // release all writers (they will panic) for { sg := c.sendq.dequeue() if sg == nil { break } sg.elem = nil if sg.releasetime != 0 { sg.releasetime = cputicks() } gp := sg.g gp.param = nil if raceenabled { raceacquireg(gp, c.raceaddr()) } glist.push(gp) } unlock(\u0026amp;c.lock) ... } 协程调度 将所有 glist 中的 goroutine 状态从 _Gwaiting 设置为 _Grunnable 状态，等待调度器的调度：\nfunc closechan(c *hchan) { // Ready all Gs now that we've dropped the channel lock. for !glist.empty() { gp := glist.pop() gp.schedlink = 0 goready(gp, 3) } } 后续所有的 goroutine 允许被重新调度后。若原本还在被动阻塞的发送方或接收方，将重获自由，后续该干嘛就去干嘛了，再跑回其所属的应用流程。\nchannel send/recv 分析 send send 方法承担向 channel 发送具体数据的功能：\nfunc send(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf func(), skip int) { if sg.elem != nil { sendDirect(c.elemtype, sg, ep) sg.elem = nil } gp := sg.g unlockf() gp.param = unsafe.Pointer(sg) if sg.releasetime != 0 { sg.releasetime = cputicks() } goready(gp, skip+1) } func sendDirect(t *_type, sg *sudog, src unsafe.Pointer) { dst := sg.elem typeBitsBulkBarrier(t, uintptr(dst), uintptr(src), t.size) memmove(dst, src, t.size) }  调用 sendDirect 方法将待发送的数据直接拷贝到待接收变量的内存地址（执行栈）。  例如：msg := \u0026lt;-ch 语句，也就是将数据从 ch 直接拷贝到了 msg 的内存地址。   调用 sg.g 属性， 从 sudog 中获取等待接收数据的 goroutine，并传递后续唤醒所需的参数。 调用 goready 方法唤醒需接收数据的 goroutine，期望从 _Gwaiting 状态调度为 _Grunnable。  recv recv 方法承担在 channel 中接收具体数据的功能：\nfunc recv(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf func(), skip int) { if c.dataqsiz == 0 { if ep != nil { recvDirect(c.elemtype, sg, ep) } } else { qp := chanbuf(c, c.recvx) if ep != nil { typedmemmove(c.elemtype, ep, qp) } typedmemmove(c.elemtype, qp, sg.elem) c.recvx++ if c.recvx == c.dataqsiz { c.recvx = 0 } c.sendx = c.recvx // c.sendx = (c.sendx+1) % c.dataqsiz } sg.elem = nil gp := sg.g unlockf() gp.param = unsafe.Pointer(sg) if sg.releasetime != 0 { sg.releasetime = cputicks() } goready(gp, skip+1) } 该方法在接受上分为两种情况，分别是直接接收和缓冲接收：\n 直接接收（不存在缓冲区）：  调用 recvDirect 方法，其作用与 sendDirect 方法相对，会直接从发送方的 goroutine 调用栈中将数据拷贝过来到接收方的 goroutine。   缓冲接收（存在缓冲区）：  调用 chanbuf 方法，根据 recvx 索引的位置读取缓冲区元素，并将其拷贝到接收方的内存地址。 拷贝完毕后，对 sendx 和 recvx 索引位置进行调整。    最后还是常规的 goroutine 调度动作，会调用 goready 方法来唤醒当前所处理的 sudog 的对应 goroutine。那么在下一轮调度时，既然已经接收了数据，自然发送方也就会被唤醒。\n总结 在本文中我们针对 Go 语言的 channel 进行了基本概念的分析和讲解，同时还针对 channel 的设计原理和四大操作（创建、发送、接收、关闭）进行了源码分析和图示分析。\n初步看过一遍后，再翻看。不难发现，Go 的 channel 设计并不复杂，记住他的数据结构就是带缓存的环形队列，再加上对称的 sendq、recvq 等双向链表的辅助属性，就能勾画出 channel 的基本逻辑流转模型。\n在具体的数据传输上，都是围绕着 “边界上下限处理，上互斥锁，阻塞/非阻塞，缓冲/非缓冲，缓存出队列，拷贝数据，解互斥锁，协程调度” 在不断地流转处理。在基本逻辑上也是相对重合的，因为发送和接收，创建和关闭总是相对的。\n如果更进一步深入探讨，还可以围绕着 CSP 模型、goroutine 调度等进一步的思考和理解。这一块会在后续的章节中再一步展开。\n"});})();